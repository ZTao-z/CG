// ImGUI
#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
// GLEW/GLAD
#include <glad/glad.h>
// GLFW
#include <GLFW/glfw3.h>
// OTHER
#include <iostream>
#include <cstdio>
#include <string>


void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) {
	// 当用户按下ESC键,我们设置window窗口的WindowShouldClose属性为true
	// 关闭应用程序
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
		glfwSetWindowShouldClose(window, GL_TRUE);
	}	
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
	glViewport(0, 0, width, height);
}

// 创建顶点着色器
const char* shader =  "#version 330 core\n\
						layout(location = 0) in vec3 pos;\n\
						layout(location = 1) in vec3 color;\n\
						out vec3 outColor;\n\
						void main() {\n\
							gl_Position = vec4(pos, 1.0);\n\
							outColor = color;\n\
						}\0";
// 创建片段着色器
const char* fragment = "#version 330 core\n\
						in vec3 outColor;\n\
						out vec4 color;\n\
						void main() {\n\
							color = vec4(outColor, 1.0f);\n\
						}\0";

const int WINDOW_WIDTH = 800;
const int WINDOW_HEIGHT = 600;

int main() {
	// 实例化GLFW窗口
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
	// 创建一个窗口对象
	GLFWwindow* window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, "LearnOpenGL", nullptr, nullptr);
	if (window == nullptr) {
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(window);
	// OpenGL渲染窗口的尺寸大小
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	// 开始游戏循环之前注册函数至合适的回调(Esc退出)
	glfwSetKeyCallback(window, key_callback);

	// 初始化GLEW/GLAD
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
		std::cout << "Failed to initialize GLAD" << std::endl;
		return -1;
	}

	// 初始化ImGUI
	IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO(); (void)io;
	ImGui::StyleColorsClassic();
	ImGui_ImplGlfw_InitForOpenGL(window, true);
	ImGui_ImplOpenGL3_Init("#version 150");
	

	/*绘制三角形*/
	//============================================
	// 编译顶点着色器
	unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertexShader, 1, &shader, NULL);
	glCompileShader(vertexShader);
	// 检测是否成功编译
	int success;
	char infoLog[512];
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
	if (!success) {
		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
		std::cout << "ERROR: " << infoLog << std::endl;
	}
	
	// 编译片段着色器
	unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragmentShader, 1, &fragment, NULL);
	glCompileShader(fragmentShader);
	// 检测是否成功编译
	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
	if (!success) {
		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
		std::cout << "ERROR: " << infoLog << std::endl;
	}
	// 创建着色器程序
	unsigned int shaderProgram = glCreateProgram();
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	glLinkProgram(shaderProgram);
	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
	if (!success) {
		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
		std::cout << "ERROR: " << infoLog << std::endl;
	}
	// 删除着色器对象
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);

	// ImGUI控制部分(颜色)
	ImVec4 topColor0 = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
	ImVec4 leftColor0 = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
	ImVec4 rightColor0 = ImVec4(0.0f, 0.0f, 1.0f, 1.0f);
	ImVec4 topColor1 = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
	ImVec4 leftColor1 = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
	ImVec4 rightColor1 = ImVec4(0.0f, 0.0f, 1.0f, 1.0f);
	ImVec4 sameColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);

	unsigned int indices[] = { // 注意索引从0开始
		0, 1, 2, // 第一个三角形
		3, 4, 5  // 第二个三角形
	};

	// 游戏循环
	unsigned int VBO, VAO, EBO;
	bool show_normal_triangle = true, 
		 show_bonus_triangle = false, 
		 show_bonus_line = false,
		 show_bonus_point = false,
		 change_all_color = false;
	ImVec4 clear_color = ImVec4(0.0f, 0.0f, 0.0f, 1.00f);
	while (!glfwWindowShouldClose(window)) {
		// 检查事件
		glfwPollEvents();

		ImVec4 left, right, top;
		left = change_all_color ? sameColor : leftColor0;
		right = change_all_color ? sameColor : rightColor0;
		top = change_all_color ? sameColor : topColor0;
		// 顶点坐标
		GLfloat vertices[] = {
			// 位置(x,y,z)       // 颜色(r,g,b)
			-0.5f, -0.5f, 0.0f, left.x, left.y, left.z, // 左下
			0.5f, -0.5f, 0.0f, right.x, right.y, right.z, // 右下
			0.0f,  0.5f, 0.0f, top.x, top.y, top.z,  // 上
			-0.25f, -0.9f, 0.0f, leftColor1.x, leftColor1.y, leftColor1.z, // 左下
			0.25f, -0.9f, 0.0f, rightColor1.x, rightColor1.y, rightColor1.z, // 右下
			0.0f,   -0.5f, 0.0f, topColor1.x, topColor1.y, topColor1.z  // 上
		};

		/*总流程*/
		// 使用glGenBuffers函数和一个缓冲ID生成一个VBO对象
		glGenBuffers(1, &VBO);
		// 使用glGenBuffers函数和一个缓冲ID生成一个EBO对象
		glGenBuffers(1, &EBO);
		// 使用glGenBuffers函数和一个缓冲ID生成一个VAO对象
		glGenVertexArrays(1, &VAO);
		// 绑定VAO
		glBindVertexArray(VAO);
		// 缓冲类型:顶点缓冲
		glBindBuffer(GL_ARRAY_BUFFER, VBO);
		// 顶点数据复制到缓冲的内存中
		glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
		// 缓冲类型:索引缓冲
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
		// 索引数据复制到缓冲的内存中
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
		// 顶点属性指针
		// 位置
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
		glEnableVertexAttribArray(0);
		// 颜色
		glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
		glEnableVertexAttribArray(1);
		// 解除绑定
		glBindBuffer(GL_ARRAY_BUFFER, 0);

		// ImGUI生成
		ImGui_ImplOpenGL3_NewFrame();
		ImGui_ImplGlfw_NewFrame();
		ImGui::NewFrame();

		// 设置GUI窗口内容
		bool showWindow = true;
		if (showWindow) {
			if (!change_all_color) {
				ImGui::Begin("Color Choose");
				ImGui::BeginChild("triangle 1", ImVec2(380, 90));
				ImGui::Text("Normal triangle");
				ImGui::ColorEdit3("top color", (float*)&topColor0);
				ImGui::ColorEdit3("bottom left color", (float*)&leftColor0);
				ImGui::ColorEdit3("bottom right color", (float*)&rightColor0);
				ImGui::EndChild();
				ImGui::BeginChild("triangle 2", ImVec2(380, 90));
				ImGui::Text("Bonus triangle");
				ImGui::ColorEdit3("top color", (float*)&topColor1);
				ImGui::ColorEdit3("bottom left color", (float*)&leftColor1);
				ImGui::ColorEdit3("bottom right color", (float*)&rightColor1);
				ImGui::EndChild();
				ImGui::End();
			}

			ImGui::Begin("Display option", &showWindow);
			ImGui::Checkbox("change whole triangle", &change_all_color);
			ImGui::Text("(Single Choice)");
			ImGui::Checkbox("normal triangle", &show_normal_triangle);
			ImGui::Checkbox("bonus line", &show_bonus_line);
			ImGui::Checkbox("bonus point", &show_bonus_point);
			ImGui::Checkbox("bonus triangle", &show_bonus_triangle);
			ImGui::End();

			if (change_all_color) {
				ImGui::Begin("Whole triangle");
				ImGui::ColorEdit3("All color", (float*)&sameColor);
				ImGui::End();
			}
		}

		// 渲染指令
		ImGui::Render();
		
		int display_w, display_h;
		glfwMakeContextCurrent(window);
		glfwGetFramebufferSize(window, &display_w, &display_h);
		glViewport(0, 0, display_w, display_h);
		// 清除窗口的移动轨迹
		glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
		glClear(GL_COLOR_BUFFER_BIT);
		// 使用着色器程序
		glUseProgram(shaderProgram);
		// 绘制物体
		glBindVertexArray(VAO);
		if (show_normal_triangle) {
			show_bonus_triangle = false;
			show_bonus_line = false;
			show_bonus_point = false;
			glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, (void*)0);
		}
		if (show_bonus_triangle) {
			show_normal_triangle = false;
			show_bonus_line = false;
			show_bonus_point = false;
			glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void*)0);
		}
		if (show_bonus_line) {
			show_normal_triangle = false;
			show_bonus_triangle = false;
			show_bonus_point = false;
			// bonus line为两个三角形的底边
			glDrawArrays(GL_LINE_STRIP, 0, 2);
			glDrawArrays(GL_LINE_STRIP, 3, 2);
		}
		if (show_bonus_point) {
			show_normal_triangle = false;
			show_bonus_triangle = false;
			show_bonus_line = false;
			// bonus point为两个三角形的顶点
			glDrawArrays(GL_POINTS, 0, 6);
		}
		
		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
		glfwMakeContextCurrent(window);

		// 交换缓冲
		glfwSwapBuffers(window);
		
		// 释放VBO，VAO，EBO
		glDeleteVertexArrays(1, &VAO);
		glDeleteBuffers(1, &VBO);
		glDeleteBuffers(1, &EBO);
	}

	// Cleanup
	ImGui_ImplOpenGL3_Shutdown();
	ImGui_ImplGlfw_Shutdown();
	ImGui::DestroyContext();
	//============================================

	// 释放GLFW分配的内存
	glfwDestroyWindow(window);
	glfwTerminate();
	return 0;
}
